#include "jmesh_provisioning_client.h"
#include "jmesh_provisioning.h"
#include "../../secure/ECDH/uECC.h"

#include "../../onchip_system/os_timer_event.h"
#include "../../jmesh/jmesh_print.h"
#include "../../jmesh/jmesh_pdu.h"
#include "../../jmesh/jmesh_addr.h"
#include "../../jmesh/jmesh_device.h"
#include "../../network/jmesh_netkey.h"
#include"../../network/jmesh_seq.h"
#include "../../driver/jmesh_system.h"
#include"../gatt/jmesh_gatt.h"
#include"../gatt/jmesh_proxy.h"
#include"stdbool.h"
#include "../../foundation/config/config_client_app.h"

uint8_t  gatt_provisioning_device(uint8_t* dat_out);
static uint16_t gatt_provisioning_invite(uint8_t* dat);
static uint16_t gatt_provisioning_capabilities_handler(uint8_t* dat, uint8_t* dat_out);
static uint16_t gatt_provisioning_start(uint8_t* dat);
static uint16_t gatt_provisioning_publickey(uint8_t* dat);
static uint16_t gatt_provisioning_publickey_handler(uint8_t* dat, uint8_t* dat_out);
//uint16_t gatt_provisioning_input_complete(uint8_t* dat);
//uint16_t gatt_provisioning_input_complete_handler(uint8_t* dat, uint8_t* dat_out);
static uint16_t gatt_provisioning_confirmation(uint8_t* dat);
static uint16_t gatt_provisioning_confirmation_handler(uint8_t* dat, uint8_t* dat_out);
static uint16_t gatt_provisioning_random(uint8_t* dat);
static uint16_t gatt_provisioning_random_handler(uint8_t* dat, uint8_t* dat_out);
static uint16_t gatt_provisioning_data(uint8_t* dat);
static uint16_t gatt_provisioning_complete_handler(uint8_t* dat, uint8_t* dat_out);
static uint16_t gatt_provisioning_failed(uint8_t* dat, uint8_t error_code);
static uint16_t gatt_provisioning_failed_handler(uint8_t* dat, uint8_t* dat_out);


static inline uint8_t prov_get_current_progress(void);
static inline void    prov_reset_progress(void);

//as
static provision_invite_format_t            STORED_INVITE_DATA;                 //'Invite' frame from provisioner
static provision_capabilities_format_t      STORED_CAPABILITIES_DATA;           //'Capabilities' frame from unprov device
static provision_start_format_t             STORED_START_DATA;                  //'Start' frame from provisioner
static provision_public_key_format_t        STORED_PUBLIC_KEY;                  //'Public Key' from local
static provision_public_key_format_t        STORED_PEER_PUBLIC_KEY;             //'Public Key' from remote

static uint8_t                              STORED_AUTHENTICATION_VALUE[16];    //'Authentication value' from OOB(for provisioner) or Generate by code(for unprov device)
static uint8_t                              STORED_PRIVATE_KEY[32];             //'Private Key' from local paired with local 'Public Key'
static uint8_t                              STORED_SECRET_KEY[32];              //'Secret Key' generated by remote 'Public Key' & local 'Private Key'
static uint8_t                              STORED_CONFIRMATION_SALT[16];       //'Confirmation salt' generated by 'Invite'&'Capabilities'&'Start'&'PublicKey'&'PublicKey'
static uint8_t                              STORED_SESSION_KEY[16];
static uint8_t                              STORED_SESSION_NONCE[16];
static uint8_t                              STORED_CONFIRMATION_KEY[16];

static provision_confirmation_format_t      STORED_CONFIRMATION_DATA;           //'Confirmation' frame from local
static provision_confirmation_format_t      STORED_PEER_CONFIRMATION_DATA;      //'Confirmation' frame from remote
static provision_random_format_t            STORED_RANDOM_DATA;                 //'Random' frame from local
static provision_random_format_t            STORED_PEER_RANDOM_DATA;            //'Random' frame from remote
static provision_data_format_t              STORED_PROVISION_DATA;              //'Data' frame from provisioner
static uint8_t                              STORED_DEVICE_KEY[16];              //device key at this network

static prov_pdu_type_t  CURRENT_STAGE   = Prov_Idle;



unsigned char provisioning_mac[6];
static unsigned char provisioning_connect;
static unsigned short provisioning_addr=0;
static unsigned short provisioning_handler;
static os_timer_event_t provisioning_timer;

void driver_provisioning_result(unsigned char* mac,unsigned short addr,int status,unsigned char elements,unsigned char* devkey)
{
}

//timer
static os_timer_event_t link_hold_timer;

static void link_hold_timeout_handler(void)
{
    prov_reset_progress();
    memset((uint8_t*)&STORED_INVITE_DATA, 0, sizeof(provision_invite_format_t));
    memset((uint8_t*)&STORED_CAPABILITIES_DATA, 0, sizeof(provision_capabilities_format_t));
    memset((uint8_t*)&STORED_START_DATA, 0, sizeof(provision_start_format_t));
    memset((uint8_t*)&STORED_PUBLIC_KEY, 0, sizeof(provision_public_key_format_t));
    memset((uint8_t*)&STORED_PEER_PUBLIC_KEY, 0, sizeof(provision_public_key_format_t));
    uint8_t dat_out[2];
    uint16_t len = gatt_provisioning_failed(dat_out, UnexpectedPDU);
}

static int prov_check_progress(uint8_t* dat)
{
    //provisioner action
    if (CURRENT_STAGE==Prov_Idle && dat[0]==Prov_Invite){
        os_timer_event_set(&link_hold_timer, LINK_HOLD_DURATION, (os_timer_event_caller_t)link_hold_timeout_handler, NULL);
        CURRENT_STAGE = Prov_Invite;
        return true;
    }
    if (CURRENT_STAGE==Prov_Invite && dat[0]==Prov_Capabilities){
        os_timer_event_restart(&link_hold_timer);
        CURRENT_STAGE = Prov_Start;
        return true;
    }
    if (CURRENT_STAGE==Prov_Start && dat[0]==Prov_Start){
        os_timer_event_restart(&link_hold_timer);
        CURRENT_STAGE = Prov_Public_Key;
        return true;
    }
    if (CURRENT_STAGE==Prov_Public_Key && dat[0]==Prov_Public_Key){
        os_timer_event_restart(&link_hold_timer);
        CURRENT_STAGE = Prov_Confirmation;
        return true;
    }
    if (CURRENT_STAGE==Prov_Confirmation && dat[0]==Prov_Confirmation) {
        os_timer_event_restart(&link_hold_timer);
        CURRENT_STAGE = Prov_Random;
        return true;
    }
    if (CURRENT_STAGE==Prov_Random && dat[0]==Prov_Random) {
        os_timer_event_restart(&link_hold_timer);
        CURRENT_STAGE = Prov_Data;
        return true;
    }
    if (CURRENT_STAGE==Prov_Data && dat[0]==Prov_Complete) {
        os_timer_event_remove(&link_hold_timer);
        CURRENT_STAGE = Prov_Idle;
        return true;
    }
    if (dat[0] == Prov_Failed) {
        os_timer_event_remove(&link_hold_timer);
        CURRENT_STAGE = Prov_Idle;
        return true;
    }
    os_timer_event_remove(&link_hold_timer);
    print_note("provisioning unexcept PDU,C:%x--R:%x\n",CURRENT_STAGE, dat[0]);
    return false;
}

static inline uint8_t prov_get_current_progress(void)
{
    return CURRENT_STAGE;
}

static inline void prov_reset_progress(void)
{
    CURRENT_STAGE = Prov_Idle;
}


//--------------------------------------------------------------------------------------
 uint8_t gatt_provisioning_device(uint8_t* dat_out)
{
    uint8_t len = gatt_provisioning_invite(dat_out);
    prov_check_progress(dat_out);
    return len;
}

//>>> invite
static uint16_t gatt_provisioning_invite(uint8_t* dat)
{
    provision_invite_format_t* prov_dat = (provision_invite_format_t*)(dat+1);
    dat[0] = Prov_Invite;
    prov_dat->Attention_Duration = Invite_Attention_Duration;
    STORED_INVITE_DATA = *prov_dat;
    return LEN_PROVISION_PARAMETERS[Prov_Invite] + 1;
}


//.................. capabilities
static uint16_t gatt_provisioning_capabilities_handler(uint8_t* dat, uint8_t* dat_out)
{
    print_buffer_note(sizeof(provision_capabilities_format_t),dat+1,"received Capabilities...\n");


    STORED_CAPABILITIES_DATA = *(provision_capabilities_format_t*)(dat+1);

    jmesh_pdu_t* pdu=jmesh_pdu_new(20);
	if(pdu == NULL) return 0;
    pdu->length= gatt_provisioning_start(pdu->proxy.para);
    pdu->proxy.type=JMESH_PROXY_TYPE_PROVISION;

    memcpy(&STORED_START_DATA,dat_out+1,sizeof(provision_start_format_t));
    jmesh_proxy_send(JMESH_SEND_TYPE_CONNECT,provisioning_connect,0xff,JMESH_PROXY_TYPE_PROVISION,pdu->length,pdu->pdu+2);

    CURRENT_STAGE=Prov_Public_Key;
    return gatt_provisioning_publickey(dat_out);
}

//.................. start
static uint16_t gatt_provisioning_start(uint8_t* dat)
{
    provision_start_format_t* prov_dat = (provision_start_format_t*)(dat+1);
    dat[0] = prov_get_current_progress();
    //pack start data

    //0 Algorithm
    if ((STORED_CAPABILITIES_DATA.Algorithms[0]*0x100+STORED_CAPABILITIES_DATA.Algorithms[1])&0x0001)
        prov_dat->Algorithm = Capabilities_Algorithm_FIPS_P256_EC;//Algorithms
    else
        return gatt_provisioning_failed(dat, OutofResources);

    //1 PublicKey Type
    if (STORED_CAPABILITIES_DATA.Pulibc_Key_Type&0x01)
        prov_dat->PublicKey = Capbilities_PublicKey_OOB;
    else
        prov_dat->PublicKey = Capbilities_PublicKey_NoOOB;

    do {
        //2.0 input oob
        uint16_t action = STORED_CAPABILITIES_DATA.Input_OOB_Action[0]*0x100+STORED_CAPABILITIES_DATA.Input_OOB_Action[1];
        if (STORED_CAPABILITIES_DATA.Input_OOB_Size>0 && (action&0x000f)) {
            print_info("start use input oob\n");
            prov_dat->AuthenticationMethod  = Start_Authentication_InputOOB;
            prov_dat->AuthenticationSize    = STORED_CAPABILITIES_DATA.Input_OOB_Size;
            if (action & (1<<3))
                prov_dat->AuthenticationAction  = InputOOBAct_InputAlphaNumeric;
            else if (action & (1<<2))
                prov_dat->AuthenticationAction  = InputOOBAct_InputNumeric;
            else if (action & (1<<1))
                prov_dat->AuthenticationAction  = InputOOBAct_Twist;
            else
                prov_dat->AuthenticationAction  = InputOOBAct_Push;
            break;
        }
        //2.1 output oob
        action = STORED_CAPABILITIES_DATA.Output_OOB_Action[0]*0x100+STORED_CAPABILITIES_DATA.Output_OOB_Action[1];
        if (STORED_CAPABILITIES_DATA.Output_OOB_Size>0 && (action&0x001f)) {
            print_info("start use output oob\n");
            prov_dat->AuthenticationMethod  = Start_Authentication_OutputOOB;
            prov_dat->AuthenticationSize    = STORED_CAPABILITIES_DATA.Output_OOB_Size;
            if (action & (1<<4))
                prov_dat->AuthenticationAction  = OutputOOBAct_OutputAlphaNumeric;
            else if (action & (1<<3))
                prov_dat->AuthenticationAction  = OutputOOBAct_OutputNumeric;
            else if (action & (1<<2))
                prov_dat->AuthenticationAction  = OutputOOBAct_Vibrate;
            else if (action & (1<<1))
                prov_dat->AuthenticationAction  = OutputOOBAct_Beep;
            else
                prov_dat->AuthenticationAction  = OutputOOBAct_Blink;
            break;
        }
        //2.2 static oob
        if (STORED_CAPABILITIES_DATA.Static_OOB_Type & 0x01) {
            print_info("start use static oob\n");
            //static oob available
            prov_dat->AuthenticationMethod  = Start_Authentication_StaticOOb;
            prov_dat->AuthenticationSize    = 0;
            prov_dat->AuthenticationAction  = 0;
            break;
        }
        //2.3 none oob
        print_info("start use no oob\n");
        prov_dat->AuthenticationMethod      = Start_Authentication_NoOOB;
        prov_dat->AuthenticationSize        = 0;
        prov_dat->AuthenticationAction      = 0;
    }while(0);

    return LEN_PROVISION_PARAMETERS[Prov_Start] + 1;
}

//>>> public key
static uint16_t gatt_provisioning_publickey(uint8_t* dat)
{
    print_note("sending public key...\n");
    provision_public_key_format_t* prov_dat = (provision_public_key_format_t*)(dat+1);
    dat[0] = prov_get_current_progress();
    //make public key and private key
    if (!uECC_make_key((uint8_t*)&STORED_PUBLIC_KEY, STORED_PRIVATE_KEY, uECC_secp256r1()))
        return gatt_provisioning_failed(dat, OutofResources);

    memcpy((uint8_t*)prov_dat, (uint8_t*)&STORED_PUBLIC_KEY, 64);
    do_authentication_action(STORED_INVITE_DATA.Attention_Duration, &STORED_START_DATA, STORED_AUTHENTICATION_VALUE);
    return LEN_PROVISION_PARAMETERS[Prov_Public_Key] + 1;
}

///<<< public key
static uint16_t gatt_provisioning_publickey_handler(uint8_t* dat, uint8_t* dat_out)
{
    print_note("received public key...\n");

    STORED_PEER_PUBLIC_KEY = *(provision_public_key_format_t*)(dat+1);
    if (!uECC_shared_secret((uint8_t*)&STORED_PEER_PUBLIC_KEY, STORED_PRIVATE_KEY, STORED_SECRET_KEY, uECC_secp256r1()))
        return gatt_provisioning_failed(dat, OutofResources);
    return gatt_provisioning_confirmation(dat_out);
}

//>>> confirmation (ONLY FOR client)
static uint16_t gatt_provisioning_confirmation(uint8_t* dat)
{
    print_note("sending confirmation...\n");
    provision_confirmation_format_t* prov_dat = (provision_confirmation_format_t*)(dat+1);
    dat[0] = prov_get_current_progress();

    calculate_confirmation(&STORED_INVITE_DATA,
                            &STORED_CAPABILITIES_DATA,
                            &STORED_START_DATA,
                            &STORED_PUBLIC_KEY,
                            &STORED_PEER_PUBLIC_KEY,
                            STORED_SECRET_KEY,
                            STORED_AUTHENTICATION_VALUE,
                            &STORED_RANDOM_DATA,
                            &STORED_CONFIRMATION_DATA,
                            STORED_CONFIRMATION_SALT,
                            STORED_CONFIRMATION_KEY);
    *prov_dat = STORED_CONFIRMATION_DATA;
    return LEN_PROVISION_PARAMETERS[Prov_Confirmation]+1;
}

//<<< confirmation
static uint16_t gatt_provisioning_confirmation_handler(uint8_t* dat, uint8_t* dat_out)
{
    print_note("received confirmation...\n");

    verify_authentication_action(&STORED_START_DATA, STORED_AUTHENTICATION_VALUE);
    //TODO: start attention timer
    STORED_PEER_CONFIRMATION_DATA = *(provision_confirmation_format_t*)(dat+1);
    return gatt_provisioning_random(dat_out);
}

//>>> random
static uint16_t gatt_provisioning_random(uint8_t* dat)
{
    print_note("sending random...\n");
    provision_random_format_t* prov_dat = (provision_random_format_t*)(dat+1);
    dat[0] = prov_get_current_progress();
    *prov_dat = STORED_RANDOM_DATA;
    return LEN_PROVISION_PARAMETERS[Prov_Random]+1;
}

//<<< random
static uint16_t gatt_provisioning_random_handler(uint8_t* dat, uint8_t* dat_out)
{
    print_note("provisioning recv random");

    STORED_PEER_RANDOM_DATA = *(provision_random_format_t*)(dat+1);
    //check confirmation
    if (check_confirmation(&STORED_PEER_RANDOM_DATA, STORED_AUTHENTICATION_VALUE, STORED_CONFIRMATION_KEY, &STORED_PEER_CONFIRMATION_DATA)) {
        //calculate provision keys and nonce
        calculate_provision_key(STORED_CONFIRMATION_SALT,
                            &STORED_PEER_RANDOM_DATA,
                            &STORED_RANDOM_DATA,
                            STORED_SECRET_KEY,
                            STORED_SESSION_KEY,
                            STORED_SESSION_NONCE,
                            STORED_DEVICE_KEY);
        return gatt_provisioning_data(dat_out);
    }
    else {
        return gatt_provisioning_failed(dat_out, ConfirmationFailed);
    }
}
//>>> data
static uint16_t gatt_provisioning_data(uint8_t* dat)
{
    unsigned long iv_index;
    provision_data_format_t* prov_dat = (provision_data_format_t*)(dat+1);
    dat[0]=Prov_Data;
    jmesh_netkey_state_get(0,prov_dat->network_key);

    prov_dat->key_index[0]=prov_dat->key_index[1]=0;
    prov_dat->flags=0;
    iv_index=jmesh_netkey_get_iv_index(0);
    JMESH_BIG_ENDIAN_FILL4(iv_index,prov_dat->iv_index);

    prov_dat->unicast_addr[0]=provisioning_addr;
    prov_dat->unicast_addr[1]=(unsigned char)(provisioning_addr>>8);
//    memcpy(prov_dat->network_key, 0, 16);
//    prov_dat->key_index[0] = ;
//    prov_dat->key_index[1] = ;
//    prov_dat->flags = ;
//    prov_dat->iv_index[0] = ;
//    prov_dat->iv_index[1] = ;
//    prov_dat->iv_index[2] = ;
//    prov_dat->iv_index[3] = ;
//    prov_dat->unicast_addr[0] = ;
//    prov_dat->unicast_addr[1] = ;

//TODO: get net information
    print_buffer_note(LEN_PROVISION_PARAMETERS[Prov_Data]+1,dat,"provisioning param:");
    encrypt_provision_data(STORED_SESSION_KEY,STORED_SESSION_NONCE,prov_dat);
    print_buffer_note(LEN_PROVISION_PARAMETERS[Prov_Data]+1,dat,"provisioning secured param:");
    return LEN_PROVISION_PARAMETERS[Prov_Data]+1;
}


//.......................................<<< complete
static uint16_t gatt_provisioning_complete_handler(uint8_t* dat, uint8_t* dat_out)
{
    print_buffer_note(16,STORED_DEVICE_KEY,"provisioning completed mac:%x,%x,%x,%x,%x,%x,addr:%x,elements:%d,devkey:\n",
                      provisioning_mac[0],provisioning_mac[1],provisioning_mac[2],provisioning_mac[3],provisioning_mac[4],provisioning_mac[5],
                        provisioning_addr,STORED_CAPABILITIES_DATA.Num_of_Elements);
    driver_provisioning_result(provisioning_mac,provisioning_addr,PROV_COMPLETED,STORED_CAPABILITIES_DATA.Num_of_Elements,STORED_DEVICE_KEY);

    prov_reset_progress();
    jmesh_device_new(provisioning_addr,STORED_CAPABILITIES_DATA.Num_of_Elements,provisioning_mac,STORED_DEVICE_KEY);

    config_composition_get(provisioning_addr,0,0);
    //jmesh_connect_drop(jmesh_connect_get_by_id(provisioning_connect));
    //may continue to config parameters
    //close link(Mutex)
    return 0;
}

//>>> failed
static uint16_t gatt_provisioning_failed(uint8_t* dat, uint8_t error_code)
{
    print_note("provisioning send step[%d] failed[%d]\n",CURRENT_STAGE,error_code);

    driver_provisioning_result(provisioning_mac,provisioning_addr,error_code,STORED_CAPABILITIES_DATA.Num_of_Elements,STORED_DEVICE_KEY);
    provision_failed_format_t* prov_dat = (provision_failed_format_t*)(dat+1);
    dat[0] = Prov_Failed;
    prov_dat->error_code = error_code;
    //TODO: close link(Mutex)
    prov_reset_progress();

    os_timer_event_remove(&provisioning_timer);
    return LEN_PROVISION_PARAMETERS[Prov_Failed]+1;
}

//<<< failed
static uint16_t gatt_provisioning_failed_handler(uint8_t* dat, uint8_t* dat_out)
{
    print_note("provisioning failed[%d] recv\n",dat[1]);
    return 0;
}

typedef uint16_t (*gatt_prov_provisioner_handler_t)(uint8_t*, uint8_t*);
extern  gatt_prov_provisioner_handler_t gatt_provisioning_client_handler[Prov_Idle];
//prov client
gatt_prov_provisioner_handler_t gatt_provisioning_client_handler[Prov_Idle] = {
    //[Prov_Invite]       = gatt_provisioning_invite_handler,
    [Prov_Capabilities] = gatt_provisioning_capabilities_handler,
    //[Prov_Start]        = gatt_provisioning_start_handler,
    [Prov_Public_Key]   = gatt_provisioning_publickey_handler,
    [Prov_Confirmation] = gatt_provisioning_confirmation_handler,
    [Prov_Random]       = gatt_provisioning_random_handler,
    //[Prov_Data]         = gatt_provisioning_data_handler,
    [Prov_Complete]     = gatt_provisioning_complete_handler,
    [Prov_Failed]       = gatt_provisioning_failed_handler
};

uint16_t gatt_provisioning_client_handlers(uint8_t* dat_in, uint8_t* dat_out)
{
    uint16_t length = 0;
    if (!prov_check_progress(dat_in))
        return gatt_provisioning_failed(dat_out, UnexpectedPDU);

    if (dat_in[0]<Prov_Idle && gatt_provisioning_client_handler[dat_in[0]]!=NULL)
        length = (*gatt_provisioning_client_handler[dat_in[0]])(dat_in, dat_out);
    else
        length = gatt_provisioning_failed(dat_out, InvalidPDU);
    return length;
}

#define JMESH_INIT_IV_INDEX 0x12345678

//static  unsigned char mac[6];
//static   unsigned char connect;

void jmesh_create_net(unsigned short nid,unsigned char* netkey,unsigned char* devkey,unsigned short primary_address)
{
    unsigned char mac[6]={0,0,0,0,0,0};
    if(0==primary_address||primary_address>=0x8000){
        print_error("create net invalid primary address=%x",primary_address);
        return;
    }
    print_buffer_note(16,netkey,"create net nid=0x%x,iv_index=0x%x,primary address=0x%x,key:",nid,JMESH_INIT_IV_INDEX,primary_address);


    jmesh_set_primary_addr(primary_address);
    jmesh_seq_set_local(1);
    jmesh_netkey_test_set_iv_index(nid,JMESH_INIT_IV_INDEX);
    jmesh_netkey_state_set(nid,netkey);
    jmesh_device_new(primary_address,2,mac,devkey);
}
void prov_result_connect_fail(void){
    driver_provisioning_result(provisioning_mac,0,PROV_ERROR_CANNOT_CONNECT,0,STORED_DEVICE_KEY);
}
void prov_result_time_flow(void){
    driver_provisioning_result(provisioning_mac,0,PROV_ERROR_TIME_FLOW,0,STORED_DEVICE_KEY);

}

void jmesh_provisioning_device(unsigned char* mac,unsigned short primary_address){
   // jmesh_gatt_t* connect;
    memcpy(provisioning_mac,mac,6);
    provisioning_addr=primary_address;
    os_timer_event_set(&provisioning_timer,2000,(os_timer_event_caller_t)prov_result_connect_fail,NULL);

//    jmesh_routing_connect(mac);
 //   print_info("provite connect mac:%x,%x,%x,%x,%x,%x",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
}

void jmesh_provisioning_connected(unsigned char* mac,unsigned short connect_id){
    //unsigned char buffer[6];
    print_info("provite connected mac:%x,%x,%x,%x,%x,%x",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);

    if(0==memcmp(provisioning_mac,mac,6)){
        jmesh_pdu_t* pdu;
        pdu=jmesh_pdu_new(5);
		if(pdu == NULL) return ;

        provisioning_connect=connect_id;
        prov_reset_progress();

        pdu->length=gatt_provisioning_device(pdu->proxy.para);
        pdu->proxy.type=JMESH_PROXY_TYPE_PROVISION;
        //print_info("start provite cid %d len=%d,data:%x %x\n",provisioning_connect,pdu->length,buffer[0],buffer[1]);
        jmesh_proxy_send(JMESH_SEND_TYPE_CONNECT,provisioning_connect,0xff,JMESH_PROXY_TYPE_PROVISION,pdu->length,pdu->pdu+2);

        os_timer_event_set(&provisioning_timer, 1000, (os_timer_event_caller_t)prov_result_time_flow, NULL);


    }
}
int jmesh_provisioning_client_process(unsigned char connect,unsigned char in_len,unsigned char * in_data,
                                unsigned char out_len,unsigned char* out_buffer)
{
    int len;
    if(connect==provisioning_connect){
        len=gatt_provisioning_client_handlers(in_data,out_buffer);
        if(len)
            os_timer_event_reset(&provisioning_timer);
        return len;
    }
    print_error("provision connect %d need %d\n",connect,provisioning_connect);
    return 0;
}

